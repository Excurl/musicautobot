# AUTOGENERATED! DO NOT EDIT! File to edit: develop/multitask_transformer/transform.ipynb (unless otherwise specified).

__all__ = ['MultitrackItem', 'combine2chordarr', 'split_melodychords']

# Cell
from ..imports import *
from ..music_transformer.transform import *
from ..numpy_encode import *

class MultitrackItem():
    def __init__(self, melody:MusicItem, chords:MusicItem, stream=None):
        self.melody,self.chords = melody, chords
        self.vocab = melody.vocab
        self._stream = stream

    @classmethod
    def from_file(cls, midi_file, vocab):
        # Part 1. Compress rests and long notes
        try:
            stream = file2stream(midi_file) # 1.
        except Exception as e:
            return print('Could not parse stream:', midi_file, e)
        return cls.from_stream(stream, vocab)

    @classmethod
    def from_stream(cls, stream, vocab):
        try:
            stream = split_melodychords(stream)
        except Exception as e:
            return print('Could not parse stream:', e)

        try:
            chordarr = stream2chordarr(stream) # 2. max_dur = quarter_len * sample_freq (4). 128 = 8 bars
            chordarr = trim_chordarr_rests(chordarr)
            chordarr = shorten_chordarr_rests(chordarr)
        except Exception as e:
            return print('Could not encode to chordarr:', e)

        # Individual parts must have notes
        parts = [part_enc(chordarr, i) for i in range(chordarr.shape[1])]
        parts = [p for p in parts if is_valid_npenc(p)]
        if len(parts) != 2: return print('Could not encode to npenc')

        mpart, cpart = parts
        if not 16 < len(mpart) < 2048: return print('Invalid Melody length')
        if not 16 < len(cpart) < 2048: return print('Invalid Chord length')

        return cls.from_npenc_parts(mpart, cpart, vocab, stream)

    @classmethod
    def from_npenc_parts(cls, mpart, cpart, vocab, stream=None):
        mpart = npenc2idxenc(mpart, seq_type=SEQType.Melody, vocab=vocab, add_eos=False)
        cpart = npenc2idxenc(cpart, seq_type=SEQType.Chords, vocab=vocab, add_eos=False)
        return MultitrackItem(MusicItem(mpart, vocab), MusicItem(cpart, vocab), stream)

    @classmethod
    def from_idx(cls, item, vocab):
        m, c = item
        return MultitrackItem(MusicItem.from_idx(m, vocab), MusicItem.from_idx(c, vocab))
    def to_idx(self): return self.melody.to_idx(), self.chords.to_idx()

    @property
    def stream(self):
        self._stream = self.to_stream() if self._stream is None else self._stream
        return self._stream

    def to_stream(self, bpm=120):
        ps = self.melody.to_npenc(), self.chords.to_npenc()
        ps = [npenc2chordarr(p) for p in ps]
        chordarr = chordarr_combine_parts(ps)
        return chordarr2stream(chordarr, bpm=bpm)


    def show(self, format:str=None):
        return self.stream.show(format)
    def play(self): self.stream.show('midi')

    def transpose(self, val):
        return MultitrackItem(self.melody.transpose(val), self.chords.transpose(val))
    def pad_to(self, val):
        return MultitrackItem(self.melody.pad_to(val), self.chords.pad_to(val))
    def trim_to_beat(self, beat):
        return MultitrackItem(self.melody.trim_to_beat(beat), self.chords.trim_to_beat(beat))

    def __len__(self):
        return max([len(self.melody), len(self.chords)])

    def save(self, path):
        if path.suffix == '.npy':
            np.save(path, self.to_idx())
        if path.suffix == '.mid':
            self.stream.write('midi', path)

# Cell
def combine2chordarr(np1, np2, vocab):
    if len(np1.shape) == 1: np1 = idxenc2npenc(np1, vocab)
    if len(np2.shape) == 1: np2 = idxenc2npenc(np2, vocab)
    p1 = npenc2chordarr(np1)
    p2 = npenc2chordarr(np2)
    return chordarr_combine_parts((p1, p2))

# Cell
def split_melodychords(stream):
    if not isinstance(stream, music21.stream.Score): stream = stream.voicesToParts()
    stream = validate_stream(stream.quantize())

    ## Should we filter out pitches outside of max keyboard notes here?
    ## Should we set max duration of notes here?

    invalid_parts = [p for p in stream.parts if not is_valid_part(p)]
    if invalid_parts: print(f'Found {len(invalid_parts)} invalid parts')
    stream.remove(invalid_parts)
    num_parts = len(stream.parts)
    if num_parts > 2: raise ValueError('Could not extract melody and chords. Midi file must contain exactly 2 tracks')
    elif num_parts == 1:
        stream = separate_melody_chord(stream)

    m, c = list(stream.parts)
    if len(list(m.getElementsByClass('Chord'))) > len(list(c.getElementsByClass('Chord'))):
        raise ValueError('Inverted melody track and chord track. Skipping...')

    return stream